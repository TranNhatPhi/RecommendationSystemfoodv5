"""
AI Agent Enhanced v·ªõi LLM, RAG, ChromaDB v√† MCP
T√≠ch h·ª£p GPT-4 API, Vector Database, Google Maps
"""

import os
import json
import logging
from typing import List, Dict, Any, Optional
import openai
import chromadb
from chromadb.config import Settings
import pandas as pd
from langchain.embeddings import OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import Chroma
from langchain.schema import Document
import requests
from datetime import datetime
import asyncio
import aiohttp

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class EnhancedFoodAIAgent:
    """
    AI Agent t∆∞ v·∫•n m√≥n ƒÉn v·ªõi t√≠ch h·ª£p:
    - GPT-4 API cho LLM processing
    - ChromaDB cho vector storage
    - RAG cho retrieval augmented generation
    - Google Maps API cho location services
    - MCP (Model Context Protocol) support
    """

    def __init__(self):
        self.setup_apis()
        self.setup_vector_db()
        self.setup_prompt_templates()
        self.load_food_data()

    def setup_apis(self):
        """Thi·∫øt l·∫≠p API keys v√† clients"""
        # OpenAI API setup
        self.openai_api_key = os.getenv(
            'OPENAI_API_KEY', 'your-openai-api-key-here')
        openai.api_key = self.openai_api_key

        # Google Maps API setup
        self.google_maps_api_key = os.getenv(
            'GOOGLE_MAPS_API_KEY', 'your-google-maps-api-key-here')

        # Embeddings model
        self.embeddings = OpenAIEmbeddings(openai_api_key=self.openai_api_key)

        logger.info("‚úÖ APIs configured successfully")

    def setup_vector_db(self):
        """Thi·∫øt l·∫≠p ChromaDB cho vector storage"""
        try:
            # ChromaDB client
            self.chroma_client = chromadb.PersistentClient(
                path="./chroma_food_db",
                settings=Settings(allow_reset=True)
            )

            # Collection for food data
            self.food_collection = self.chroma_client.get_or_create_collection(
                name="food_recommendations",
                metadata={"hnsw:space": "cosine"}
            )

            # Collection for customer data
            self.customer_collection = self.chroma_client.get_or_create_collection(
                name="customer_profiles",
                metadata={"hnsw:space": "cosine"}
            )

            logger.info("‚úÖ ChromaDB initialized successfully")

        except Exception as e:
            logger.error(f"‚ùå ChromaDB setup failed: {e}")
            # Fallback to in-memory
            self.chroma_client = chromadb.Client()
            self.food_collection = self.chroma_client.create_collection(
                "food_recommendations")
            self.customer_collection = self.chroma_client.create_collection(
                "customer_profiles")

    def setup_prompt_templates(self):
        """Thi·∫øt l·∫≠p prompt templates chuy√™n nghi·ªáp"""
        self.system_prompt = """
B·∫°n l√† m·ªôt chuy√™n gia t∆∞ v·∫•n ·∫©m th·ª±c v√† dinh d∆∞·ª°ng AI, c√≥ nhi·ªám v·ª• ƒë∆∞a ra c√°c g·ª£i √Ω m√≥n ƒÉn an to√†n, h·ª£p v·ªá sinh, ph√π h·ª£p v·ªõi t·ª´ng nh√≥m ng∆∞·ªùi d√πng. 

NHI·ªÜM V·ª§ CH√çNH:
- ƒê·∫£m b·∫£o an to√†n th·ª±c ph·∫©m v√† v·ªá sinh cho ng∆∞·ªùi ti√™u d√πng
- T∆∞ v·∫•n m√≥n ƒÉn ph√π h·ª£p v·ªõi t√¨nh tr·∫°ng s·ª©c kh·ªèe c√° nh√¢n
- ƒê∆∞a ra g·ª£i √Ω s√°ng t·∫°o, th·ª±c t·∫ø v√† d·ªÖ th·ª±c hi·ªán
- ∆Øu ti√™n gi·∫£i ph√°p dinh d∆∞·ª°ng c√¢n b·∫±ng

PHONG C√ÅCH T∆Ø∆†NG T√ÅC:
- Th√¢n thi·ªán, d·ªÖ hi·ªÉu, chuy√™n nghi·ªáp
- Gi·∫£i th√≠ch r√µ r√†ng l√Ω do ƒë·∫±ng sau m·ªói g·ª£i √Ω
- Cung c·∫•p th√¥ng tin dinh d∆∞·ª°ng c·ª• th·ªÉ
- ƒê∆∞a ra c·∫£nh b√°o an to√†n khi c·∫ßn thi·∫øt

D·ª∞A TR√äN:
- D·ªØ li·ªáu kh√°ch h√†ng v√† l·ªãch s·ª≠ t∆∞∆°ng t√°c
- Th√¥ng tin dinh d∆∞·ª°ng v√† an to√†n th·ª±c ph·∫©m
- Xu h∆∞·ªõng ·∫©m th·ª±c ƒë·ªãa ph∆∞∆°ng
- Khuy·∫øn ngh·ªã y t·∫ø chung
"""

        self.user_prompt_template = """
TH√îNG TIN KH√ÅCH H√ÄNG:
- ID: {customer_id}
- Th√¥ng tin c√° nh√¢n: {customer_info}
- L·ªãch s·ª≠ m√≥n ƒÉn: {food_history}
- S·ªü th√≠ch: {preferences}
- H·∫°n ch·∫ø/D·ªã ·ª©ng: {restrictions}

C√ÇU H·ªéI C·ª¶A NG∆Ø·ªúI D√ôNG:
{user_question}

NG·ªÆ C·∫¢NH B·ªî SUNG (t·ª´ RAG):
{context_info}

V·ªä TR√ç HI·ªÜN T·∫†I:
{location_info}

Y√äU C√ÇU PH·∫¢N H·ªíI:
1. G·ª£i √Ω m√≥n ƒÉn c·ª• th·ªÉ (3-5 m√≥n)
2. L√Ω do ch·ªçn m√≥n (dinh d∆∞·ª°ng, ph√π h·ª£p)
3. C·∫£nh b√°o an to√†n (n·∫øu c√≥)
4. G·ª£i √Ω ƒë·ªãa ƒëi·ªÉm g·∫ßn nh·∫•t (n·∫øu c·∫ßn)
5. M·∫πo ch·∫ø bi·∫øn/b·∫£o qu·∫£n
"""

    def load_food_data(self):
        """Load v√† embedding d·ªØ li·ªáu m√≥n ƒÉn v√†o ChromaDB"""
        try:
            # Load interactions data
            interactions_df = pd.read_csv('interactions_enhanced_final.csv')
            customers_df = pd.read_csv('customers_data.csv')

            self.interactions_data = interactions_df
            self.customers_data = customers_df

            # Check if data already embedded
            if self.food_collection.count() == 0:
                self._embed_food_data(interactions_df)

            if self.customer_collection.count() == 0:
                self._embed_customer_data(customers_df)

            logger.info(
                f"‚úÖ Loaded {len(interactions_df)} interactions and {len(customers_df)} customers")

        except Exception as e:
            logger.error(f"‚ùå Failed to load food data: {e}")
            # Create dummy data for testing
            self.interactions_data = pd.DataFrame()
            self.customers_data = pd.DataFrame()

    def _embed_food_data(self, df: pd.DataFrame):
        """Embed food interaction data v√†o ChromaDB"""
        logger.info("üîÑ Embedding food data...")

        batch_size = 100
        total_rows = len(df)

        for i in range(0, total_rows, batch_size):
            batch = df.iloc[i:i+batch_size]

            documents = []
            metadatas = []
            ids = []

            for _, row in batch.iterrows():
                # Create document text for embedding
                doc_text = f"""
                M√≥n ƒÉn: {row.get('food_name', 'Unknown')}
                Lo·∫°i: {row.get('food_category', 'Unknown')}
                ƒê√°nh gi√°: {row.get('rating', 0)}/5
                Dinh d∆∞·ª°ng: Calories: {row.get('calories', 0)}, Protein: {row.get('protein', 0)}g
                M√¥ t·∫£: {row.get('description', '')}
                Th√†nh ph·∫ßn: {row.get('ingredients', '')}
                """

                documents.append(doc_text)
                metadatas.append({
                    'food_id': str(row.get('food_id', i)),
                    'food_name': str(row.get('food_name', 'Unknown')),
                    'category': str(row.get('food_category', 'Unknown')),
                    'rating': float(row.get('rating', 0)),
                    'calories': int(row.get('calories', 0)),
                    'protein': float(row.get('protein', 0))
                })
                ids.append(f"food_{i}_{row.get('food_id', i)}")

            # Add to ChromaDB
            self.food_collection.add(
                documents=documents,
                metadatas=metadatas,
                ids=ids
            )

            logger.info(f"üìä Embedded {i+len(batch)}/{total_rows} food items")

    def _embed_customer_data(self, df: pd.DataFrame):
        """Embed customer profile data v√†o ChromaDB"""
        logger.info("üîÑ Embedding customer data...")

        for _, row in df.iterrows():
            doc_text = f"""
            Kh√°ch h√†ng: {row.get('full_name', 'Unknown')}
            Tu·ªïi: {row.get('age_group', 'Unknown')}
            ƒê·ªãa ƒëi·ªÉm: {row.get('location', 'Unknown')}
            S·ªü th√≠ch: {row.get('preferences', '')}
            H·∫°n ch·∫ø: {row.get('dietary_restrictions', '')}
            """

            self.customer_collection.add(
                documents=[doc_text],
                metadatas=[{
                    'customer_id': str(row.get('customer_id', '')),
                    'name': str(row.get('full_name', 'Unknown')),
                    'age_group': str(row.get('age_group', 'Unknown')),
                    'location': str(row.get('location', 'Unknown'))
                }],
                ids=[f"customer_{row.get('customer_id', '')}"]
            )

    async def get_recommendation(self, customer_id: str, question: str, location: str = None) -> Dict[str, Any]:
        """
        Main method ƒë·ªÉ l·∫•y g·ª£i √Ω t·ª´ AI Agent
        T√≠ch h·ª£p RAG + LLM + Location services
        """
        try:
            # 1. L·∫•y th√¥ng tin kh√°ch h√†ng
            customer_info = self._get_customer_info(customer_id)

            # 2. RAG - T√¨m ki·∫øm th√¥ng tin li√™n quan
            context_info = await self._rag_search(question, customer_id)

            # 3. L·∫•y th√¥ng tin ƒë·ªãa ƒëi·ªÉm
            location_info = await self._get_location_context(location) if location else "Kh√¥ng c√≥ th√¥ng tin v·ªã tr√≠"

            # 4. T·∫°o prompt v√† g·ªçi LLM
            response = await self._call_llm(
                customer_id=customer_id,
                customer_info=customer_info,
                user_question=question,
                context_info=context_info,
                location_info=location_info
            )

            # 5. L∆∞u interaction history
            await self._save_interaction(customer_id, question, response)

            return {
                'success': True,
                'response': response,
                'customer_info': customer_info,
                'context_used': context_info,
                'location_context': location_info,
                'processing_steps': self._get_processing_steps(),
                'timestamp': datetime.now().isoformat()
            }

        except Exception as e:
            logger.error(f"‚ùå Recommendation failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'fallback_response': "Xin l·ªói, c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau."
            }

    def _get_customer_info(self, customer_id: str) -> Dict[str, Any]:
        """L·∫•y th√¥ng tin kh√°ch h√†ng t·ª´ database"""
        try:
            # Query from ChromaDB
            results = self.customer_collection.query(
                query_texts=[f"customer_id:{customer_id}"],
                n_results=1
            )

            if results['documents']:
                customer_data = results['metadatas'][0][0]

                # Get interaction history
                interactions = self.interactions_data[
                    self.interactions_data['customer_id'] == int(customer_id)
                ] if not self.interactions_data.empty else pd.DataFrame()

                return {
                    'customer_id': customer_id,
                    'name': customer_data.get('name', 'Unknown'),
                    'age_group': customer_data.get('age_group', 'Unknown'),
                    'location': customer_data.get('location', 'Unknown'),
                    'total_interactions': len(interactions),
                    'favorite_foods': self._get_favorite_foods(interactions),
                    'avg_rating': interactions['rating'].mean() if not interactions.empty else 0
                }
            else:
                return {
                    'customer_id': customer_id,
                    'name': 'Kh√°ch h√†ng m·ªõi',
                    'note': 'Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠'
                }

        except Exception as e:
            logger.error(f"‚ùå Failed to get customer info: {e}")
            return {'customer_id': customer_id, 'error': 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin kh√°ch h√†ng'}

    def _get_favorite_foods(self, interactions: pd.DataFrame) -> List[str]:
        """L·∫•y danh s√°ch m√≥n ƒÉn y√™u th√≠ch"""
        if interactions.empty:
            return []

        # L·∫•y top m√≥n ƒÉn c√≥ rating cao
        top_foods = interactions[interactions['rating']
                                 >= 4]['food_name'].value_counts().head(5)
        return top_foods.index.tolist()

    async def _rag_search(self, question: str, customer_id: str) -> str:
        """RAG - Retrieval Augmented Generation search"""
        try:
            # Search relevant food items
            food_results = self.food_collection.query(
                query_texts=[question],
                n_results=5
            )

            # Search similar customer profiles
            customer_results = self.customer_collection.query(
                query_texts=[f"t∆∞∆°ng t·ª± kh√°ch h√†ng {customer_id}"],
                n_results=3
            )

            # Combine results
            context_parts = []

            if food_results['documents'][0]:
                context_parts.append("TH√îNG TIN M√ìN ƒÇN LI√äN QUAN:")
                for i, doc in enumerate(food_results['documents'][0][:3]):
                    metadata = food_results['metadatas'][0][i]
                    context_parts.append(
                        f"- {metadata['food_name']}: {doc[:200]}...")

            if customer_results['documents'][0]:
                context_parts.append("\nKH√ÅCH H√ÄNG T∆Ø∆†NG T·ª∞:")
                for doc in customer_results['documents'][0][:2]:
                    context_parts.append(f"- {doc[:150]}...")

            return "\n".join(context_parts) if context_parts else "Kh√¥ng t√¨m th·∫•y th√¥ng tin li√™n quan"

        except Exception as e:
            logger.error(f"‚ùå RAG search failed: {e}")
            return "L·ªói t√¨m ki·∫øm th√¥ng tin ng·ªØ c·∫£nh"

    async def _get_location_context(self, location: str) -> str:
        """L·∫•y th√¥ng tin ƒë·ªãa ƒëi·ªÉm t·ª´ Google Maps API"""
        try:
            if not location or self.google_maps_api_key == 'your-google-maps-api-key-here':
                return "Kh√¥ng c√≥ th√¥ng tin v·ªã tr√≠"

            # Google Places API - t√¨m nh√† h√†ng g·∫ßn ƒë√≥
            url = "https://maps.googleapis.com/maps/api/place/nearbysearch/json"
            params = {
                'location': location,
                'radius': 2000,
                'type': 'restaurant',
                'key': self.google_maps_api_key
            }

            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    data = await response.json()

                    if data['status'] == 'OK':
                        restaurants = []
                        for place in data['results'][:5]:
                            restaurants.append({
                                'name': place['name'],
                                'rating': place.get('rating', 0),
                                'address': place.get('vicinity', 'N/A')
                            })

                        return f"Nh√† h√†ng g·∫ßn b·∫°n: {', '.join([r['name'] for r in restaurants])}"

        except Exception as e:
            logger.error(f"‚ùå Location context failed: {e}")

        return "Kh√¥ng th·ªÉ l·∫•y th√¥ng tin v·ªã tr√≠"

    async def _call_llm(self, customer_id: str, customer_info: Dict, user_question: str,
                        context_info: str, location_info: str) -> str:
        """G·ªçi GPT-4 API v·ªõi prompt ƒë∆∞·ª£c t·ªëi ∆∞u"""
        try:
            # Prepare user prompt
            user_prompt = self.user_prompt_template.format(
                customer_id=customer_id,
                customer_info=json.dumps(
                    customer_info, ensure_ascii=False, indent=2),
                food_history=customer_info.get('favorite_foods', []),
                preferences="D·ª±a tr√™n l·ªãch s·ª≠ t∆∞∆°ng t√°c",
                restrictions="C·∫ßn x√°c ƒë·ªãnh th√™m",
                user_question=user_question,
                context_info=context_info,
                location_info=location_info
            )

            # Call OpenAI API
            response = await openai.ChatCompletion.acreate(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=1500,
                temperature=0.7
            )

            return response.choices[0].message.content

        except Exception as e:
            logger.error(f"‚ùå LLM call failed: {e}")
            # Fallback response
            return self._generate_fallback_response(customer_info, user_question)

    def _generate_fallback_response(self, customer_info: Dict, question: str) -> str:
        """T·∫°o ph·∫£n h·ªìi d·ª± ph√≤ng khi LLM kh√¥ng kh·∫£ d·ª•ng"""
        customer_name = customer_info.get('name', 'b·∫°n')
        favorite_foods = customer_info.get('favorite_foods', [])

        response = f"Xin ch√†o {customer_name}! "

        if favorite_foods:
            response += f"D·ª±a tr√™n l·ªãch s·ª≠, t√¥i th·∫•y b·∫°n th√≠ch {', '.join(favorite_foods[:3])}. "

        response += """
T√¥i g·ª£i √Ω m·ªôt s·ªë m√≥n ƒÉn an to√†n v√† b·ªï d∆∞·ª°ng:

üçú **Ph·ªü g√†**: ƒê·∫ßy ƒë·ªß dinh d∆∞·ª°ng, d·ªÖ ti√™u h√≥a, an to√†n cho m·ªçi l·ª©a tu·ªïi
ü•ó **Salad rau c·ªß**: Gi√†u vitamin, t·ªët cho s·ª©c kh·ªèe, √≠t calo
üçõ **C∆°m g√† n∆∞·ªõng**: Protein cao, c√¢n b·∫±ng dinh d∆∞·ª°ng

**L∆∞u √Ω an to√†n:**
- Ch·ªçn th·ª±c ph·∫©m t∆∞∆°i, ngu·ªìn g·ªëc r√µ r√†ng
- Ch·∫ø bi·∫øn k·ªπ, ƒë·∫£m b·∫£o v·ªá sinh
- U·ªëng nhi·ªÅu n∆∞·ªõc, ƒÉn ƒë√∫ng gi·ªù

B·∫°n c√≥ mu·ªën t√¥i g·ª£i √Ω th√™m m√≥n n√†o kh√°c kh√¥ng?
"""

        return response

    async def _save_interaction(self, customer_id: str, question: str, response: str):
        """L∆∞u l·ªãch s·ª≠ t∆∞∆°ng t√°c"""
        try:
            interaction_data = {
                'customer_id': customer_id,
                'question': question,
                'response': response,
                'timestamp': datetime.now().isoformat(),
                'model': 'gpt-4'
            }

            # Save to ChromaDB for future RAG
            doc_text = f"C√¢u h·ªèi: {question}\nTr·∫£ l·ªùi: {response[:500]}..."

            self.food_collection.add(
                documents=[doc_text],
                metadatas=[interaction_data],
                ids=[f"interaction_{customer_id}_{datetime.now().timestamp()}"]
            )

        except Exception as e:
            logger.error(f"‚ùå Failed to save interaction: {e}")

    def _get_processing_steps(self) -> List[Dict[str, str]]:
        """Tr·∫£ v·ªÅ c√°c b∆∞·ªõc x·ª≠ l√Ω cho UI visualization"""
        return [
            {
                'id': 'input_analysis',
                'title': 'üîç Ph√¢n t√≠ch ƒë·∫ßu v√†o',
                'status': 'completed',
                'description': 'X·ª≠ l√Ω v√† hi·ªÉu c√¢u h·ªèi ng∆∞·ªùi d√πng'
            },
            {
                'id': 'customer_profile',
                'title': 'üë§ T·∫£i h·ªì s∆° kh√°ch h√†ng',
                'status': 'completed',
                'description': 'Truy xu·∫•t th√¥ng tin v√† l·ªãch s·ª≠ kh√°ch h√†ng'
            },
            {
                'id': 'rag_search',
                'title': 'üîé T√¨m ki·∫øm RAG',
                'status': 'completed',
                'description': 'T√¨m ki·∫øm th√¥ng tin li√™n quan t·ª´ vector database'
            },
            {
                'id': 'location_context',
                'title': 'üìç Ng·ªØ c·∫£nh v·ªã tr√≠',
                'status': 'completed',
                'description': 'L·∫•y th√¥ng tin ƒë·ªãa ƒëi·ªÉm t·ª´ Google Maps'
            },
            {
                'id': 'llm_processing',
                'title': 'üß† X·ª≠ l√Ω LLM',
                'status': 'completed',
                'description': 'G·ªçi GPT-4 ƒë·ªÉ t·∫°o g·ª£i √Ω th√¥ng minh'
            },
            {
                'id': 'response_formatting',
                'title': 'üìù ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi',
                'status': 'completed',
                'description': 'T·ªëi ∆∞u h√≥a v√† ƒë·ªãnh d·∫°ng c√¢u tr·∫£ l·ªùi'
            }
        ]


# Singleton instance
_enhanced_agent_instance = None


def get_enhanced_agent_instance() -> EnhancedFoodAIAgent:
    """Get singleton instance c·ªßa Enhanced AI Agent"""
    global _enhanced_agent_instance
    if _enhanced_agent_instance is None:
        _enhanced_agent_instance = EnhancedFoodAIAgent()
    return _enhanced_agent_instance

# Test function


async def test_agent():
    """Test function ƒë·ªÉ ki·ªÉm tra agent"""
    agent = get_enhanced_agent_instance()

    result = await agent.get_recommendation(
        customer_id="1001",
        question="T√¥i mu·ªën ƒÉn m√≥n g√¨ v·ª´a t·ªët cho s·ª©c kh·ªèe v·ª´a ngon mi·ªáng?",
        location="10.762622,106.660172"  # Ho Chi Minh City coordinates
    )

    print("üéØ Test Result:")
    print(json.dumps(result, ensure_ascii=False, indent=2))

if __name__ == "__main__":
    # Run test
    asyncio.run(test_agent())
